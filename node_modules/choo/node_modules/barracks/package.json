{
  "name": "barracks",
  "version": "8.3.1",
  "description": "Action dispatcher for unidirectional data flows",
  "main": "index.js",
  "scripts": {
    "test": "standard && NODE_ENV=test node test",
    "test:cov": "standard && NODE_ENV=test istanbul cover test.js",
    "watch": "watch 'npm t'"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/yoshuawuyts/barracks.git"
  },
  "keywords": [
    "action",
    "dispatcher",
    "emitter",
    "event",
    "flux",
    "minimal",
    "react",
    "react-component"
  ],
  "license": "MIT",
  "devDependencies": {
    "bundle-collapser": "^1.2.1",
    "coveralls": "~2.11.12",
    "es2020": "^1.1.6",
    "istanbul": "~0.4.5",
    "noop2": "^2.0.0",
    "standard": "^8.0.0",
    "tape": "^4.6.0",
    "uglifyify": "^3.0.2",
    "unassertify": "^2.0.3",
    "watch": "^0.19.2"
  },
  "dependencies": {
    "xtend": "^4.0.1"
  },
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "apply-hook.js"
  ],
  "readme": "# barracks\n[![NPM version][npm-image]][npm-url]\n[![build status][travis-image]][travis-url]\n[![Test coverage][coveralls-image]][coveralls-url]\n[![Downloads][downloads-image]][downloads-url]\n\nAction dispatcher for unidirectional data flows. Creates tiny models of data\nthat can be accessed with actions through a small API.\n\n## Usage\n````js\nconst barracks = require('barracks')\n\nconst store = barracks()\n\nstore.use({\n  onError: (err, state, createSend) => {\n    console.error(`error: ${err}`)\n  },\n  onAction: (data, state, name, caller, createSend) => {\n    console.log(`data: ${data}`)\n  },\n  onStateChange: (data, state, prev, caller, createSend) => {\n    console.log(`state: ${prev} -> ${state}`)\n  }\n})\n\nstore.model({\n  namespace: 'cakes',\n  state: {},\n  effects: {},\n  reducers: {},\n  subscriptions: {}\n})\n\nconst createSend = store.start({ noSubscriptions: true })\nconst send = createSend('myDispatcher', true)\ndocument.addEventListener('DOMContentLoaded', () => {\n  store.start() // fire up subscriptions\n  const state = store.state()\n  send('foo:start', { name: 'Loki' })\n})\n````\n\n## API\n### store = barracks(hooks?)\nInitialize a new `barracks` instance. Takes an optional object of hooks which\nis passed to `.use()`.\n\n### store.use(hooks)\nRegister new hooks on the store. Hooks are little plugins that can extend\nbehavior or perform actions at specific points in the life cycle. The following\nhooks are possible:\n- __onError(err, state, createSend):__ called when an `effect` or\n  `subscription` emit an error; if no hook is passed, the default hook will\n  `throw` on each error\n- __onAction(data, state, name, caller, createSend):__ called when an `action`\n  is fired\n- __onStateChange(data, state, prev, caller, createSend):__ called after a\n  reducer changes the `state`.\n- __wrapSubscriptions(fn):__ wraps a `subscription` to add custom behavior\n- __wrapReducers(fn):__ wraps a `reducer` to add custom behavior\n- __wrapEffects(fn):__ wraps an `effect` to add custom behavior\n- __wrapInitialState(fn):__ mutate the initial `state` to add custom\n  behavior - useful to mutate the state before starting up\n\n`createSend()` is a special function that allows the creation of a new named\n`send()` function. The first argument should be a string which is the name, the\nsecond argument is a boolean `callOnError` which can be set to `true` to call\nthe `onError` hook instead of a provided callback. It then returns a\n`send(actionName, data?)` function.\n\nHooks should be used with care, as they're the most powerful interface into\nthe state. For application level code, it's generally recommended to delegate to\nactions inside models using the `send()` call, and only shape the actions\ninside the hooks.\n\n### store.model()\nRegister a new model on the store. Models are optionally namespaced objects\nwith an initial `state` and handlers for dealing with data:\n- __namespace:__ namespace the model so that it cannot access any properties\n  and handlers in other models\n- __state:__ initial values of `state` inside the model\n- __reducers:__ synchronous operations that modify state; triggered by `actions`\n- __effects:__ asynchronous operations that don't modify state directly;\n  triggered by `actions`, can call `actions`\n- __subscriptions:__ asynchronous read-only operations that don't modify state\n  directly; can call `actions`\n\n`state` within handlers is immutable through `Object.freeze()` and thus cannot\nbe modified. Return data from `reducers` to modify `state`. See [handler\nsignatures](#handler-signatures) for more info on the handlers.\n\nFor debugging purposes, internal references to values can be inspected through a\nseries of private accessors:\n- `store._subscriptions`\n- `store._reducers`\n- `store._effects`\n- `store._models`\n\n### state = store.state(opts)\nGet the current state from the store. Opts can take the following values:\n- __freeze:__ default: true; set to false to not freeze state in handlers\n  using `Object.freeze()`; useful for optimizing performance in production\n  builds\n- __state:__ pass in a state object that will be merged with the state returned\n  from the store; useful for rendering in Node\n\n### send = createSend(name) = store.start(opts)\nStart the store and get a `createSend(name)` function. Pass a unique `name` to\n`createSend()` to get a `send()` function. Opts can take the following values:\n- __subscriptions:__ default: true; set to false to not register\n  `subscriptions` when starting the application; useful to delay `init`\n  functions until the DOM has loaded\n- __effects:__ default: true; set to `false` to not register `effects` when\n  starting the application; useful when only wanting the initial `state`\n- __reducers:__ default: true; set to false to not register `reducers` when\n  starting the application; useful when only wanting the initial `state`\n\nIf the store has disabled any of the handlers (e.g. `{ reducers: false }`),\ncalling `store.start()` a second time will register the remaining values. This\nis useful if not everything can be started at the same time (e.g. have\n`subscriptions` wait for the `DOMContentLoaded` event).\n\n### send(name, data?)\nSend a new action to the models with optional data attached. Namespaced models\ncan be accessed by prefixing the name with the namespace separated with a `:`,\ne.g. `namespace:name`.\n\n## Handler signatures\nThese are the signatures for the properties that can be passed into a model.\n\n### namespace\nAn optional string that causes `state`, `effects` and `reducers` to be\nprefixed.\n\n```js\napp.model({\n  namespace: 'users'\n})\n```\n\n### state\nState can either be a value or an object of values that is used as the initial\nstate for the application. If namespaced the values will live under\n`state[namespace]`.\n```js\napp.model({\n  namespace: 'hey',\n  state: { foo: 'bar' }\n})\napp.model({\n  namespace: 'there',\n  state: { bin: [ 'beep', 'boop' ] }\n})\napp.model({\n  namespace: 'people',\n  state: 'oi'\n}})\n```\n\n### reducers\nReducers are synchronous functions that return a value synchronously. No\neventual values, just values that are relevant for the state. It takes two\narguments of `data` and `state`. `data` is the data that was emitted, and\n`state` is the current state. Each action has a name that can be accessed\nthrough `send(name)`, and when under a namespace can be accessed as\n`send(namespace:name)`. When operating under a namespace, reducers only have\naccess to the state within the namespace.\n```js\n// some model\napp.model({\n  namespace: 'plantcake',\n  state: {\n    enums: [ 'veggie', 'potato', 'lettuce' ]\n    paddie: 'veggie'\n  }\n})\n\n// so this model can't access anything in the 'plantcake' namespace\napp.model({\n  namespace: 'burlybeardos',\n  state: { count: 1 },\n  reducers: {\n    feedPlantcake: (data, state) => {\n      return { count: state.count + 1 }\n    },\n    trimBeard: (data, state) => ({ count: state.count - 1 })\n  }\n})\n```\n\n### effects\n`effects` are asynchronous methods that can be triggered by `actions` in\n`send()`. They never update the state directly, but can instead do thing\nasynchronously, and then call `send()` again to trigger a `reducer` that can\nupdate the state. `effects` can also trigger other `effects`, making them fully\ncomposable. Generally, it's recommended to only have `effects` without a\n`namespace` call other `effects`, as to keep namespaced models as isolated as\npossible.\n\nWhen an `effect` is done executing, or encounters an error, it should call the\nfinal `done(err)` callback. If the `effect` was called by another `effect` it\nwill call the callback of the caller. When an error propagates all the way to\nthe top, the `onError` handler will be called, registered in\n`barracks(handlers)`. If no callback is registered, errors will `throw`.\n\nHaving callbacks in `effects` means that error handling can be formalized\nwithout knowledge of the rest of the application leaking into the model. This\nalso causes `effects` to become fully composable, which smooths parallel\ndevelopment in large teams, and keeps the mental overhead low when developing a\nsingle model.\n\n```js\nconst http = require('xhr')\nconst app = barracks({\n  onError: (data, state, prev, send) => send('app:error', data)\n})\n\napp.model({\n  namespace: 'app',\n  effects: {\n    error: (data, state, send, done) => {\n      // if doing http calls here be super sure not to get lost\n      // in a recursive error handling loop: remember this IS\n      // the error handler\n      console.error(data.message)\n      done()\n    }\n  }\n})\n\napp.model({\n  namespace: 'foo',\n  state: { foo: 1 },\n  reducers: {\n    moreFoo: (data, state) => ({ foo: state.foo + data.count })\n  }\n  effects: {\n    fetch: (data, state, send, done) => {\n      http('foobar.com', function (err, res, body) {\n        if (err || res.statusCode !== 200) {\n          return done(new Error({\n            message: 'error accessing server',\n            error: err\n          }))\n        } else {\n          send('moreFoo', { count: foo.count }, done)\n        }\n      })\n    }\n  }\n})\n```\n\n### subscriptions\n`subscriptions` are read-only sources of data. This means they cannot be\ntriggered by actions, but can emit actions themselves whenever they want. This\nis useful for stuff like listening to keyboard events or incoming websocket\ndata. They should generally be started when the application is loaded, using\nthe `DOMContentLoaded` listener.\n\n```js\napp.model({\n  subscriptions: {\n    emitWoofs: (send, done) => {\n      // emit a woof every second\n      setInterval(() =>  send('printWoofs', { woof: 'meow?' }, done), 1000)\n    }\n  },\n  effects: {\n    printWoofs: (data, state) => console.log(data.woof)\n  }\n})\n```\n`done()` is passed as the final argument so if an error occurs in a subscriber,\nit can be communicated to the `onError` hook.\n\n## FAQ\n### What is an \"action dispatcher\"?\nAn action dispatcher gets data from one place to another without tightly\ncoupling code. The best known use case for this is in the `flux` pattern. Say\nyou want to update a piece of data (for example a user's name), instead of\ndirectly calling the update logic inside the view, the action calls a function\nthat updates the user's name for you. Now all the views that need to update a\nuser's name can call the same action and pass in the relevant data. This\npattern tends to make views more robust and easier to maintain.\n\n### Why did you build this?\nPassing messages around should not be complicated. Many `flux` implementations\ncasually throw restrictions at users without having a clear architecture. I\ndon't like that. `barracks` is a package that creates a clear flow of data within an\napplication, concerning itself with state, code separation, and data flow. I\nbelieve that having strong opinions and being transparent in them makes for\nbetter architectures than sprinkles of opinions left and right, without a cohesive\nstory as to _why_.\n\n### How is this different from choo?\n`choo` is a framework that handles views, data and all problems related to\nthat. This is a package that only concerns itself with data flow, without being\nexplicitly tied to the DOM.\n\n### This looks like more than five functions!\nWelllll, no. It's technically five functions with a high arity, hah. Nah,\nyou're right - but five functions _sounds_ good. Besides: you don't need to\nknow all options and toggles to get this working; that only relevant once you\nstart hitting edge cases like we did in `choo` :sparkles:\n\n## See Also\n- [choo](https://github.com/yoshuawuyts/choo) - sturdy frontend framework\n- [sheet-router](https://github.com/yoshuawuyts/wayfarer) - fast, modular\n  client-side router\n- [yo-yo](https://github.com/maxogden/yo-yo) - template string based view\n  framework\n- [send-action](https://github.com/sethvincent/send-action) - unidirectional\n  action emitter\n\n## Installation\n```sh\n$ npm install barracks\n```\n\n## License\n[MIT](https://tldrlegal.com/license/mit-license)\n\n[npm-image]: https://img.shields.io/npm/v/barracks.svg?style=flat-square\n[npm-url]: https://npmjs.org/package/barracks\n[travis-image]: https://img.shields.io/travis/yoshuawuyts/barracks/master.svg?style=flat-square\n[travis-url]: https://travis-ci.org/yoshuawuyts/barracks\n[coveralls-image]: https://img.shields.io/coveralls/yoshuawuyts/barracks.svg?style=flat-square\n[coveralls-url]: https://coveralls.io/r/yoshuawuyts/barracks?branch=master\n[downloads-image]: http://img.shields.io/npm/dm/barracks.svg?style=flat-square\n[downloads-url]: https://npmjs.org/package/barracks\n\n[flux]: http://facebook.github.io/react/blog/2014/05/06/flux.html\n[browserify]: https://github.com/substack/node-browserify\n",
  "readmeFilename": "README.md",
  "gitHead": "7e7243f245dfd71df986f8fa006e3ac28abd0417",
  "bugs": {
    "url": "https://github.com/yoshuawuyts/barracks/issues"
  },
  "homepage": "https://github.com/yoshuawuyts/barracks#readme",
  "_id": "barracks@8.3.1",
  "_shasum": "d33dae40a035f6e1ed92025ffdd87fcb33103c84",
  "_from": "barracks@>=8.1.1 <9.0.0"
}
